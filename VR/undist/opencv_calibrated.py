from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import numpy as np

try:
    import cv2  # type: ignore
except ImportError as exc:  # pragma: no cover - handled at pipeline level
    cv2 = None  # type: ignore

try:
    import yaml  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    yaml = None  # type: ignore

from VR.undist.base import Undistorter, UndistortionResult


@dataclass(frozen=True)
class CalibrationData:
    K: np.ndarray
    D: np.ndarray
    reference_size: Tuple[int, int]
    source: str


def _ensure_cv2() -> None:
    if cv2 is None:
        raise RuntimeError("OpenCV is required for calibrated fisheye undistortion")


def _load_file(path: Path) -> Any:
    text = path.read_text(encoding="utf-8")
    try:
        return json.loads(text)
    except json.JSONDecodeError:
        if yaml is None:
            raise ValueError(f"Failed to parse calibration file '{path}'. Install PyYAML or provide JSON.")
        return yaml.safe_load(text)


def _extract_matrix(data: Dict[str, Any], *keys: str) -> Optional[np.ndarray]:
    for key in keys:
        if key in data:
            arr = np.asarray(data[key], dtype=np.float64)
            if arr.size == 9:
                return arr.reshape(3, 3)
            if arr.shape == (3, 3):
                return arr.astype(np.float64)
    return None


def _extract_distortion(data: Dict[str, Any], *keys: str) -> Optional[np.ndarray]:
    for key in keys:
        if key in data:
            arr = np.asarray(data[key], dtype=np.float64).reshape(-1)
            if arr.size >= 4:
                return arr[:4].reshape(4, 1)
    return None


def _extract_reference_size(data: Dict[str, Any]) -> Optional[Tuple[int, int]]:
    candidates = [
        data.get("dim1"),
        data.get("image_size"),
        data.get("resolution"),
        data.get("size"),
        (data.get("width"), data.get("height")),
    ]
    for item in candidates:
        if item is None:
            continue
        if isinstance(item, (list, tuple)) and len(item) >= 2:
            w = int(item[0])
            h = int(item[1])
            if w > 0 and h > 0:
                return (w, h)
    return None


def load_calibration(path: str, *, fallback_size: Optional[Tuple[int, int]] = None) -> CalibrationData:
    """Load calibration data from JSON/YAML files generated by calibration tools."""
    calibration_path = Path(path)
    if not calibration_path.exists():
        raise FileNotFoundError(f"Calibration file not found: {path}")
    data = _load_file(calibration_path)
    if not isinstance(data, dict):
        raise ValueError(f"Calibration file {path} must contain a JSON/YAML object")

    K = _extract_matrix(data, "K", "camera_matrix", "mtx", "intrinsic_matrix")
    if K is None:
        raise ValueError(f"Calibration file {path} does not contain a 3x3 camera matrix under keys K/camera_matrix/mtx")

    D = _extract_distortion(data, "D", "distortion_coefficients", "distCoeffs", "dist")
    if D is None:
        raise ValueError(f"Calibration file {path} does not contain fisheye distortion coefficients under keys D/distortion_coefficients")

    reference_size = _extract_reference_size(data)
    if reference_size is None:
        if fallback_size is not None:
            reference_size = fallback_size
        else:
            # Approximate from principal point assuming centered principal point.
            cx = float(K[0, 2])
            cy = float(K[1, 2])
            reference_size = (int(round(cx * 2.0)), int(round(cy * 2.0)))
            if reference_size[0] <= 0 or reference_size[1] <= 0:
                reference_size = (1, 1)

    return CalibrationData(K=K, D=D, reference_size=reference_size, source=str(calibration_path))


class OpenCVCalibratedFisheyeUndistorter(Undistorter):
    """Undistorter that relies on externally calibrated fisheye parameters."""

    def __init__(
        self,
        calibration: CalibrationData,
        *,
        balance: float = 1.0,
        mode_label: str = "opencv_calibrated",
    ) -> None:
        _ensure_cv2()
        self._calib = calibration
        self._balance = float(balance)
        self._mode_label = mode_label
        self._cache: Dict[Tuple[int, int], Tuple[np.ndarray, np.ndarray, np.ndarray]] = {}

    def _scaled_K(self, width: int, height: int) -> np.ndarray:
        ref_w, ref_h = self._calib.reference_size
        scale_x = width / float(ref_w) if ref_w > 0 else 1.0
        scale_y = height / float(ref_h) if ref_h > 0 else 1.0
        K_scaled = self._calib.K.copy()
        K_scaled[0, 0] *= scale_x
        K_scaled[0, 2] *= scale_x
        K_scaled[1, 1] *= scale_y
        K_scaled[1, 2] *= scale_y
        return K_scaled

    def _maps(self, width: int, height: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        key = (width, height)
        cached = self._cache.get(key)
        if cached is not None:
            return cached
        K_scaled = self._scaled_K(width, height)
        D = self._calib.D
        new_K = cv2.fisheye.estimateNewCameraMatrixForUndistortRectify(
            K_scaled,
            D,
            (width, height),
            np.eye(3),
            balance=self._balance,
        )
        map1, map2 = cv2.fisheye.initUndistortRectifyMap(
            K_scaled,
            D,
            np.eye(3),
            new_K,
            (width, height),
            cv2.CV_32FC1,
        )
        self._cache[key] = (map1, map2, new_K)
        return map1, map2, new_K

    @staticmethod
    def _valid_ratio(map1: np.ndarray, map2: np.ndarray, width: int, height: int) -> float:
        valid_x = (map1 >= 0.0) & (map1 <= (width - 1))
        valid_y = (map2 >= 0.0) & (map2 <= (height - 1))
        valid = valid_x & valid_y
        return float(np.count_nonzero(valid)) / float(map1.size)

    @staticmethod
    def _fold_ratio(map_arr: np.ndarray, axis: int) -> float:
        diffs = np.diff(map_arr, axis=axis)
        if diffs.size == 0:
            return 0.0
        finite = np.isfinite(diffs)
        if not finite.any():
            return 0.0
        diffs = diffs[finite]
        bad = diffs < -1e-3
        return float(bad.sum()) / float(diffs.size)

    def undistort(self, img: np.ndarray, params: Optional[Any] = None) -> UndistortionResult:
        height, width = img.shape[:2]
        map1, map2, new_K = self._maps(width, height)
        rectified = cv2.remap(img, map1, map2, interpolation=cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT)
        info = {
            "mode": self._mode_label,
            "calibration_source": self._calib.source,
            "balance": self._balance,
            "valid_ratio": self._valid_ratio(map1, map2, width, height),
            "fold_ratio_x": self._fold_ratio(map1, axis=1),
            "fold_ratio_y": self._fold_ratio(map2, axis=0),
        }
        return UndistortionResult(image=rectified, new_camera_matrix=new_K, info=info)

    def redistort_stub(self, img: np.ndarray) -> np.ndarray:
        return img.copy()
